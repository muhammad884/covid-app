import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import authServices from "./AuthServices";

const initialState = {
  admin: {
    token: "",
    isAuthenticated: false,
    loading: false,
    error: null,
    message: null,
  },
  agent: {
    token: "",
    name: "",
    email: "",
    city: "",
    isAuthenticated: false,
    loading: false,
    error: null,
    message: null,
  },
  agents: [],
  persons: [],
  personTravel: [],
};

// @desc admin login
export const adminLogin = createAsyncThunk(
  "admin/login",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.login(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

// @desc admin logout
export const adminLogout = createAsyncThunk(
  "admin/logout",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.logout(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc get all agents
export const getAgents = createAsyncThunk(
  "admin/getAgents",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.getAgents(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc send email
export const sendEmail = createAsyncThunk(
  "admin/sendEmail",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.sendEmail(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc agent register
export const agentRegister = createAsyncThunk(
  "agent/register",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.registerAgent(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

// @desc agent login
export const agentLogin = createAsyncThunk(
  "agent/login",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.agentLogin(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

// @desc agent logout
export const agentLogout = createAsyncThunk(
  "agent/logout",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.agentLogout(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc get current agent
export const getCurrentAgent = createAsyncThunk(
  "agent/getCurrentAgent",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.getCurrentAgent(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc get all persons
export const getPersons = createAsyncThunk(
  "agent/getPersons",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.getPersons(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc person register
export const addPerson = createAsyncThunk(
  "agent/personRegister",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.addPerson(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

@desc get person by id
export const getPerson = createAsyncThunk(
  "agent/getPerson",
  async (data, thunkAPI) => {
    try {
      const res = await authServices.getPerson(data);
      return res.data;
    } catch (err) {
      const message =
        (err.response && err.response.data && err.response.data.message) ||
        err.message ||
        err.toString();
      thunkAPI.rejectWithValue(message);
    }
  }
);

export const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    setAdmin: (state, action) => {
      state.admin = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder.addCase(adminLogin.pending, (state, action) => {
      state.admin.loading = true;
      state.admin.error = null;
    });
    builder.addCase(adminLogin.fulfilled, (state, action) => {
      state.admin.loading = false;
      state.admin.isAuthenticated = true;
      // state.admin.token = action.payload.token;
      // state.admin.message = action.payload.message;
    });
    builder.addCase(adminLogin.rejected, (state, action) => {
      state.admin.loading = false;
      state.admin.error = action.payload;
    });
    builder.addCase(adminLogout.pending, (state, action) => {
      state.admin.loading = true;
      state.admin.error = null;
    });
    builder.addCase(adminLogout.fulfilled, (state, action) => {
      state.admin.loading = false;
      state.admin.isAuthenticated = false;
      state.admin.token = "";
      state.admin.message = action.payload.message;
    });
    builder.addCase(adminLogout.rejected, (state, action) => {
      state.admin.loading = false;
      state.admin.error = action.payload;
    });
    builder.addCase(getAgents.pending, (state, action) => {
      state.agent.loading = true;
      state.agent.error = null;
    });
    builder.addCase(getAgents.fulfilled, (state, action) => {
      state.agent.loading = false;
      state.agents = action.payload;
    });
    builder.addCase(getAgents.rejected, (state, action) => {
      state.agent.loading = false;
      state.agent.error = action.payload;
    });
    builder.addCase(sendEmail.pending, (state, action) => {
      state.agent.loading = true;
      state.agent.error = null;
    });
    builder.addCase(sendEmail.fulfilled, (state, action) => {
      state.agent.loading = false;
      state.agent.message = action.payload.message;
    });
    builder.addCase(sendEmail.rejected, (state, action) => {
      state.agent.loading = false;
      state.agent.error = action.payload;
    });
    builder.addCase(agentRegister.pending, (state, action) => {
      state.agent.loading = true;
      state.agent.error = null;
    });
    builder.addCase(agentRegister.fulfilled, (state, action) => {
      state.agent.loading = false;
      state.agent.message = action.payload.message;
    });
    builder.addCase(agentRegister.rejected, (state, action) => {
      state.agent.loading = false;
      state.agent.error = action.payload;
    });
    builder.addCase(agentLogin.pending, (state, action) => {
      state.agent.loading = true;
      state.agent.error = null;
    });
    builder.addCase(agentLogin.fulfilled, (state, action) => {
      state.agent.loading = false;
      state.agent.isAuthenticated = true;
      state.agent.token = action.payload.token;
      state.agent.message = action.payload.message;
    });
    builder.addCase(agentLogin.rejected, (state, action) => {
      state.agent.loading = false;
      state.agent.error = action.payload;
    });
    builder.addCase(agentLogout.pending, (state, action) => {
      state.agent.loading = true;
      state.agent.error = null;
    });
    builder.addCase(agentLogout.fulfilled, (state, action) => {
      state.agent.loading = false;
      state.agent.isAuthenticated = false;
      state.agent.token = "";
      state.agent.message = action.payload.message;
    });
    builder.addCase(agentLogout.rejected, (state, action) => {
      state.agent.loading = false;
      state.agent.error = action.payload;
    });
        builder.addCase(getCurrentAgent.pending, (state, action) => {
          state.agent.loading = true;
          state.agent.error = null;
        });
        builder.addCase(getCurrentAgent.fulfilled, (state, action) => {
          state.agent.loading = false;
          state.agent.currentAgent = action.payload;
        });
        builder.addCase(getCurrentAgent.rejected, (state, action) => {
          state.agent.loading = false;
          state.agent.error = action.payload;
        });
        builder.addCase(getPersons.pending, (state, action) => {
          state.person.loading = true;
          state.person.error = null;
        });
        builder.addCase(getPersons.fulfilled, (state, action) => {
          state.person.loading = false;
          state.persons = action.payload;
        });
        builder.addCase(getPersons.rejected, (state, action) => {
          state.person.loading = false;
          state.person.error = action.payload;
        });
        builder.addCase(addPerson.pending, (state, action) => {
          state.person.loading = true;
          state.person.error = null;
        });
        builder.addCase(addPerson.fulfilled, (state, action) => {
          state.person.loading = false;
          state.person.message = action.payload.message;
        });
        builder.addCase(addPerson.rejected, (state, action) => {
          state.person.loading = false;
          state.person.error = action.payload;
        });
        builder.addCase(getPerson.pending, (state, action) => {
          state.person.loading = true;
          state.person.error = null;
        });
        builder.addCase(getPerson.fulfilled, (state, action) => {
          state.person.loading = false;
          state.person.currentPerson = action.payload;
        });
        builder.addCase(getPerson.rejected, (state, action) => {
          state.person.loading = false;
          state.person.error = action.payload;
        });
  },
});

export default authSlice.reducer;
